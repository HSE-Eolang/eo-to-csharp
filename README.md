# eo-to-csharp

Данный репозиторий содержит пример возможной трансляции программы для вычисления факториала, написанного на ео, в код на с#

Пример кода для факториала на ео:

```
[args...] > app
  stdout > @
    sprintf
      "%d"
      factorial
        (args.get 0).toInt

[n] > factorial
  if. > @
    less.
      n
      2
    1
    mul.
      n
      factorial
        sub.
          n
          1

```

Основной пример кода на с# [тут](https://github.com/HSE-Eolang/eo-to-csharp/blob/main/Program.cs) (В ходе экспермиентов добавил промежуточный объект (ComplexObject), для проверки динамического вызова поля (аттрибута))

Для удобной трансляции if, less, mul и т.д сразу в объекты, а не в конструкции на с#, реализованы стандартные объекты в папке [EOruntime](https://github.com/HSE-Eolang/eo-to-csharp/tree/main/EOruntime).
Использование объектов для таких примитивных операций отдельная тема для дискусии, т. к. реализация простейших вычиселений в виде объектов существенно
усложняет работу рантайма по обработке такого количества вложенных объектов. Например, в данном примере замена EOsub в качестве аргумента факториала на обычную операцию -, существенно ускоряет выполнение программы.

Основной идеей является использование ключевого слового dynamic, что позволяет переложить всю работу по вызову нужных методов и приведения типов на плечи DLR (dynamic language runtime) https://habr.com/ru/post/144330/

Также важным аспектом реализации является абстрактный класс [EOobject](https://github.com/HSE-Eolang/eo-to-csharp/blob/main/EOruntime/EOobject.cs), от которого должны быть унаследованы все остальные объекты. В нем содержатся две основные идеи:
  * метод Φ, который реализует отложенные вычисления и вызывается при необходимости "датаризации"
  * методы неявного приведения типа, которые будут вызваны, если объект потребуется привести к указанному типу. Каждый из методов приведения типа возвращает результат вызова Φ, что позволяет начать "датаризацию" объекта, при запросе приведения объекта к требуемому типу.

Таким образом, изначально C# снимает с нас значительную долю работу по работе с динамическими объектами, что позводяет генерировать очень короткие и лаконичные классы. Отдельной проблемой становится оптимизация работы значительного количества генерируемых вложенных классов, но даже в таком виде, данная реализация значительно быстрее предыдущих результатов.

Проект можно открыть в Visual Studio, если есть желание поэксперементировать с исходным кодом.

Для запуска самого результата нужно запустить exe или dll файл
в каталоге https://github.com/HSE-Eolang/eo-to-csharp/tree/main/bin/Release/net5.0

[ВАЖНО] Для запуска примера, необходима последняя версия [.NET Runtime](https://dotnet.microsoft.com/download/dotnet/5.0)
